<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Football Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            line-height: 1.6;
        }

        /* Header Styles */
        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 16px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        /* Position Filter */
        .position-filter {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding-bottom: 8px;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .position-filter::-webkit-scrollbar {
            display: none;
        }

        .position-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .position-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .position-btn.active {
            background: white;
            color: #2a5298;
            border-color: white;
        }

        /* Filter Controls */
        .filter-controls {
            display: flex;
            gap: 16px;
            margin-top: 16px;
            padding: 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            flex-wrap: wrap;
        }
        
        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .filter-group label {
            font-weight: 500;
            color: rgba(255,255,255,0.9);
            font-size: 14px;
        }
        
        .filter-dropdown {
            padding: 8px 12px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            min-width: 120px;
        }
        
        .filter-dropdown option {
            background: #2a5298;
            color: white;
        }
        
        .filter-controls-container {
            width: 100%;
        }

        /* API Status */
        .api-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            margin-top: 8px;
            font-size: 12px;
        }
        
        .loading {
            color: #ffd700;
            font-weight: 500;
        }
        
        .error {
            color: #ff6b6b;
            font-weight: 500;
        }
        
        .record-count {
            color: rgba(255,255,255,0.8);
        }
        
        .pagination-info {
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(255,255,255,0.8);
        }
        
        .load-more-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .load-more-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .load-more-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* View Toggle */
        .view-toggle {
            display: flex;
            background: white;
            padding: 8px;
            gap: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: sticky;
            top: 88px;
            z-index: 99;
        }

        .view-btn {
            flex: 1;
            padding: 10px;
            border: none;
            background: #f0f2f5;
            color: #666;
            font-size: 14px;
            font-weight: 500;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .view-btn.active {
            background: #2a5298;
            color: white;
        }

        /* Container */
        .container {
            padding: 16px;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Player Cards View */
        .player-grid {
            display: grid;
            gap: 12px;
            grid-template-columns: 1fr;
        }

        .player-card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .player-card:active {
            transform: scale(0.98);
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid #eee;
        }

        .player-info h3 {
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 4px;
        }

        .player-meta {
            display: flex;
            gap: 8px;
            font-size: 14px;
            color: #666;
        }

        .position-badge {
            background: #e8f0fe;
            color: #2a5298;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: 500;
        }

        /* Stat Grid */
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .stat-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #1a1a1a;
            display: block;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }

        .fantasy-points {
            font-size: 14px;
            color: #2a5298;
            font-weight: 600;
            margin-top: 2px;
        }

        /* Comparison View */
        .comparison-container {
            background: white;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .comparison-header {
            margin-bottom: 16px;
        }

        .comparison-table-wrapper {
            overflow-x: auto;
            position: relative;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 800px;
        }

        .comparison-table thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .comparison-table th {
            background: #f8f9fa;
            padding: 12px 8px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            border-bottom: 2px solid #dee2e6;
        }

        .comparison-table td {
            padding: 12px 8px;
            border-bottom: 1px solid #eee;
            font-size: 14px;
            vertical-align: top;
        }

        .comparison-table tr:last-child td {
            border-bottom: none;
        }

        .player-name-cell {
            font-weight: 600;
            color: #1a1a1a;
            min-width: 150px;
        }

        /* Stats View */
        .stats-overview {
            background: white;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 16px;
        }

        .stats-overview h2 {
            font-size: 18px;
            margin-bottom: 16px;
            color: #1a1a1a;
        }

        .stat-category {
            margin-bottom: 20px;
        }

        .stat-category-title {
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f2f5;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.3;
        }

        /* Responsive */
        @media (min-width: 768px) {
            .player-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .stat-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (min-width: 1024px) {
            .player-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .stat-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (max-width: 768px) {
            .filter-controls {
                gap: 12px;
            }
            
            .filter-group {
                flex: 1;
                min-width: calc(50% - 6px);
            }
            
            .filter-dropdown {
                width: 100%;
                min-width: 0;
            }
        }

        /* Animations */
        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Highlight best stats */
        .stat-best {
            background: #e8f5e9;
        }

        .stat-best .stat-value {
            color: #2e7d32;
        }

        /* Search Bar */
        .search-container {
            margin-bottom: 16px;
        }

        .search-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            background: white;
        }

        .search-input:focus {
            outline: none;
            border-color: #2a5298;
            box-shadow: 0 0 0 3px rgba(42, 82, 152, 0.1);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Fantasy Football Dashboard</h1>
        <div class="position-filter" id="positionFilter">
            <button class="position-btn active" data-position="ALL">All</button>
            <button class="position-btn" data-position="QB">QB</button>
            <button class="position-btn" data-position="RB">RB</button>
            <button class="position-btn" data-position="WR">WR</button>
            <button class="position-btn" data-position="TE">TE</button>
            <button class="position-btn" data-position="K">K</button>
            <button class="position-btn" data-position="DST">DST</button>
            <button class="position-btn" data-position="LB">LB</button>
            <button class="position-btn" data-position="CB">CB</button>
            <button class="position-btn" data-position="S">S</button>
            <button class="position-btn" data-position="DE">DE</button>
            <button class="position-btn" data-position="DT">DT</button>
        </div>
    </div>

    <div class="view-toggle">
        <button class="view-btn active" data-view="cards">Cards</button>
        <button class="view-btn" data-view="comparison">Compare</button>
        <button class="view-btn" data-view="stats">Stats</button>
    </div>

    <div class="container">
        <div class="search-container">
            <input type="text" class="search-input" id="searchInput" placeholder="Search players...">
        </div>
        <div id="content"></div>
    </div>

    <script>
        // IndexedDB Cache Manager
        class StatsCache {
            constructor() {
                this.dbName = 'nfl_stats_cache';
                this.version = 1;
                this.storeName = 'stats';
                this.db = null;
                this.cacheExpiryMinutes = 60; // 1 hour cache for stats data
            }

            async init() {
                if (this.db) return this.db;

                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve(this.db);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            const store = db.createObjectStore(this.storeName, { keyPath: 'cacheKey' });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                            store.createIndex('year', 'year', { unique: false });
                            store.createIndex('week', 'week', { unique: false });
                            store.createIndex('position', 'position', { unique: false });
                        }
                    };
                });
            }

            generateCacheKey(year, week, position, page) {
                return `${year}_${week}_${position}_${page}`;
            }

            async get(year, week, position, page) {
                try {
                    await this.init();
                    
                    const cacheKey = this.generateCacheKey(year, week, position, page);
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    
                    return new Promise((resolve, reject) => {
                        const request = store.get(cacheKey);
                        
                        request.onsuccess = () => {
                            const result = request.result;
                            
                            if (!result) {
                                resolve(null);
                                return;
                            }
                            
                            const now = new Date();
                            const cachedTime = new Date(result.timestamp);
                            const diffMinutes = (now - cachedTime) / (1000 * 60);
                            
                            if (diffMinutes > this.cacheExpiryMinutes) {
                                console.log(`Cache expired for ${cacheKey}, age: ${diffMinutes.toFixed(2)} minutes`);
                                resolve(null);
                                return;
                            }
                            
                            console.log(`✅ Cache hit for ${cacheKey}, age: ${diffMinutes.toFixed(2)} minutes`);
                            resolve(result.data);
                        };
                        
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Cache get error:', error);
                    return null;
                }
            }

            async set(year, week, position, page, data) {
                try {
                    await this.init();
                    
                    const cacheKey = this.generateCacheKey(year, week, position, page);
                    const cacheEntry = {
                        cacheKey,
                        year,
                        week, 
                        position,
                        page,
                        data,
                        timestamp: new Date().toISOString()
                    };
                    
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    
                    return new Promise((resolve, reject) => {
                        const request = store.put(cacheEntry);
                        
                        request.onsuccess = () => {
                            console.log(`✅ Cached data for ${cacheKey}`);
                            resolve();
                        };
                        
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Cache set error:', error);
                }
            }

            async clear(year) {
                try {
                    await this.init();
                    
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const index = store.index('year');
                    
                    return new Promise((resolve, reject) => {
                        const request = index.openCursor(IDBKeyRange.only(year));
                        
                        request.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor) {
                                cursor.delete();
                                cursor.continue();
                            } else {
                                console.log(`🗑️ Cleared cache for year ${year}`);
                                resolve();
                            }
                        };
                        
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Cache clear error:', error);
                }
            }

            async clearAll() {
                try {
                    await this.init();
                    
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    
                    return new Promise((resolve, reject) => {
                        const request = store.clear();
                        
                        request.onsuccess = () => {
                            console.log('🗑️ Cleared all cached data');
                            resolve();
                        };
                        
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Cache clear all error:', error);
                }
            }
        }

        // Stats API Manager
        class StatsAPI {
            constructor() {
                this.baseUrl = '/data/stats';
                this.cache = new StatsCache();
                this.currentRequests = new Map();
                
                // Yahoo stat ID mapping - done on FRONTEND
                this.statIdMapping = {
                    "0": "Games Played",
                    "1": "Pass Att",
                    "2": "Comp",
                    "3": "Inc", 
                    "4": "Pass Yds",
                    "5": "Pass TD",
                    "6": "Int",
                    "7": "Sack",
                    "8": "Rush Att",
                    "9": "Rush Yds", 
                    "10": "Rush TD",
                    "11": "Rec",
                    "12": "Rec Yds",
                    "13": "Rec TD",
                    "14": "Ret Yds",
                    "15": "Ret TD",
                    "16": "Off Fum Ret TD",
                    "17": "2-PT",
                    "18": "Fum",
                    "19": "Fum Lost",
                    "20": "FG",
                    "21": "FGM",
                    "22": "Pts Allow",
                    "23": "Tack Solo",
                    "24": "Tack Ast",
                    "25": "Pass Def",
                    "26": "Sack",
                    "27": "Int",
                    "28": "Fum Rec",
                    "29": "Fum Force",
                    "30": "TD",
                    "31": "Safe",
                    "32": "Blk Kick",
                    "33": "Ret Yds",
                    "34": "Ret TD",
                    "57": "Off Snaps",
                    "58": "Off Snap %",
                    "59": "Def Snaps", 
                    "60": "Def Snap %",
                    "61": "ST Snaps",
                    "62": "ST Snap %",
                    "63": "Games Started",
                    "64": "Off Plays",
                    "78": "Tack Total",
                    "79": "Tack Loss",
                    "80": "QB Hits",
                    "81": "Hurries"
                };
            }

            convertYahooStatsToReadable(rawStats, position) {
                const readableStats = {};
                
                Object.entries(rawStats).forEach(([statId, value]) => {
                    const readableName = this.statIdMapping[statId];
                    if (readableName && value != null && value !== 0) {
                        readableStats[readableName] = value;
                    }
                });

                return readableStats;
            }

            async fetchStats(year = '2024', week = 'total', position = 'ALL', page = 1) {
                const requestKey = `${year}_${week}_${position}_${page}`;
                
                if (this.currentRequests.has(requestKey)) {
                    console.log(`⏳ Waiting for pending request: ${requestKey}`);
                    return await this.currentRequests.get(requestKey);
                }

                const cachedData = await this.cache.get(year, week, position, page);
                if (cachedData) {
                    return cachedData;
                }

                const fetchPromise = this.fetchFromAPI(year, week, position, page);
                this.currentRequests.set(requestKey, fetchPromise);

                try {
                    const data = await fetchPromise;
                    
                    if (data.success) {
                        await this.cache.set(year, week, position, page, data);
                    }
                    
                    return data;
                } catch (error) {
                    console.error('Stats fetch error:', error);
                    throw error;
                } finally {
                    this.currentRequests.delete(requestKey);
                }
            }

            async fetchFromAPI(year, week, position, page) {
                const params = new URLSearchParams({
                    year,
                    week,
                    position,
                    page: page.toString(),
                    limit: '50'
                });

                const url = `${this.baseUrl}?${params}`;
                console.log(`🌐 Fetching from API: ${url}`);

                const response = await fetch(url, {
                    method: 'GET',
                    credentials: 'include',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'API request failed');
                }

                // Convert raw Yahoo stat IDs to readable names HERE on frontend
                data.data = data.data.map(player => ({
                    ...player,
                    stats: this.convertYahooStatsToReadable(player.stats, player.position)
                }));

                console.log(`✅ Fetched and converted ${data.count} players from API`);
                return data;
            }

            async clearCache(year = null) {
                if (year) {
                    await this.cache.clear(year);
                } else {
                    await this.cache.clearAll();
                }
            }
        }

        // Global state and variables
        const statsAPI = new StatsAPI();

        let currentFilters = {
            league: null,
            team: 'ALL',
            week: 'total',
            position: 'ALL',
            year: '2024'
        };

        let apiState = {
            loading: false,
            error: null,
            currentPage: 1,
            totalPages: 1,
            totalRecords: 0,
            hasMore: false
        };

        let currentPlayers = [];
        let currentView = 'cards';
        let searchQuery = '';

        // Position stat mappings
        const positionStats = {
            "QB": ["Pass Att", "Comp", "Inc", "Pass Yds", "Pass TD", "Int", "Sack", "Rush Att", "Rush Yds", "Rush TD", "Off Fum Ret TD", "2-PT", "Fum", "Fum Lost"],
            "RB": ["Rush Att", "Rush Yds", "Rush TD", "Rec", "Rec Yds", "Rec TD", "Ret Yds", "Ret TD", "Off Fum Ret TD", "2-PT", "Fum", "Fum Lost"],
            "WR": ["Rush Att", "Rush Yds", "Rush TD", "Rec", "Rec Yds", "Rec TD", "Ret Yds", "Ret TD", "Off Fum Ret TD", "2-PT", "Fum", "Fum Lost"],
            "TE": ["Rush Att", "Rush Yds", "Rush TD", "Rec", "Rec Yds", "Rec TD", "Ret Yds", "Ret TD", "Off Fum Ret TD", "2-PT", "Fum", "Fum Lost"],
            "K": ["FG", "FGM"],
            "DST": ["Pts Allow"],
            "LB": ["Ret Yds", "Ret TD", "Tack Solo", "Tack Ast", "Pass Def", "Sack", "Int", "Fum Rec", "Fum Force", "TD", "Safe", "Blk Kick"],
            "CB": ["Ret Yds", "Ret TD", "Tack Solo", "Tack Ast", "Pass Def", "Sack", "Int", "Fum Rec", "Fum Force", "TD", "Safe", "Blk Kick"],
            "S": ["Ret Yds", "Ret TD", "Tack Solo", "Tack Ast", "Pass Def", "Sack", "Int", "Fum Rec", "Fum Force", "TD", "Safe", "Blk Kick"],
            "DE": ["Ret Yds", "Ret TD", "Tack Solo", "Tack Ast", "Pass Def", "Sack", "Int", "Fum Rec", "Fum Force", "TD", "Safe", "Blk Kick"],
            "DT": ["Tack Solo", "Tack Ast", "Pass Def", "Sack", "Int", "Fum Rec", "Fum Force", "TD", "Safe", "Blk Kick", "Ret Yds", "Ret TD"]
        };

        // Key stats for card view
        const keyStats = {
            "QB": ["Pass Yds", "Pass TD", "Int", "Rush Yds"],
            "RB": ["Rush Yds", "Rush TD", "Rec", "Rec Yds"],
            "WR": ["Rec", "Rec Yds", "Rec TD", "Rush Yds"],
            "TE": ["Rec", "Rec Yds", "Rec TD", "Rush Yds"],
            "K": ["FG", "FGM"],
            "DST": ["Pts Allow"],
            "LB": ["Tack Solo", "Sack", "Int", "Fum Force"],
            "CB": ["Tack Solo", "Pass Def", "Int", "TD"],
            "S": ["Tack Solo", "Pass Def", "Int", "TD"],
            "DE": ["Tack Solo", "Sack", "Fum Force", "TD"],
            "DT": ["Tack Solo", "Sack", "Fum Force", "TD"]
        };

        // Fantasy data functions
        function getFantasyDataFromLocalStorage() {
            try {
                const storedData = localStorage.getItem('fantasyLeagueData');
                return storedData ? JSON.parse(storedData) : null;
            } catch (error) {
                console.error('Error retrieving fantasy data from localStorage:', error);
                return null;
            }
        }

        function initializeActiveLeague() {
            const fantasyData = getFantasyDataFromLocalStorage();
            if (!fantasyData || !fantasyData.leagues || Object.keys(fantasyData.leagues).length === 0) {
                return null;
            }
            
            let activeLeagueId = localStorage.getItem('activeLeagueId');
            
            if (!activeLeagueId || !fantasyData.leagues[activeLeagueId]) {
               activeLeagueId = Object.keys(fantasyData.leagues)[0];
               localStorage.setItem('activeLeagueId', activeLeagueId);
           }
           
           return activeLeagueId;
       }

       function getSavedWeek() {
           const savedWeek = localStorage.getItem('selectedWeek');
           if (savedWeek && savedWeek !== 'current') {
               return savedWeek === 'total' ? 'total' : parseInt(savedWeek);
           }
           return 'total';
       }

       function saveWeekPreference(week) {
           if (week) {
               localStorage.setItem('selectedWeek', week.toString());
           } else {
               localStorage.setItem('selectedWeek', 'total');
           }
       }

       // Filter controls
       function createFilterControls() {
           const fantasyData = getFantasyDataFromLocalStorage();
           const activeLeagueId = currentFilters.league || initializeActiveLeague();
           const activeLeague = fantasyData?.leagues?.[activeLeagueId];
           
           return `
               <div class="filter-controls">
                   <div class="filter-group">
                       <label for="year-select">Year:</label>
                       <select id="year-select" class="filter-dropdown">
                           <option value="2024" ${currentFilters.year === '2024' ? 'selected' : ''}>2024</option>
                           <option value="2023" ${currentFilters.year === '2023' ? 'selected' : ''}>2023</option>
                       </select>
                   </div>
                   
                   <div class="filter-group">
                       <label for="week-select">Week:</label>
                       <select id="week-select" class="filter-dropdown">
                           <option value="total" ${currentFilters.week === 'total' ? 'selected' : ''}>Season Total</option>
                           ${Array.from({length: 18}, (_, i) => i + 1).map(week => `
                               <option value="${week}" ${currentFilters.week === week.toString() ? 'selected' : ''}>
                                   Week ${week}
                               </option>
                           `).join('')}
                       </select>
                   </div>
                   
                   ${fantasyData?.leagues && Object.keys(fantasyData.leagues).length > 0 ? `
                       <div class="filter-group">
                           <label for="league-select">League:</label>
                           <select id="league-select" class="filter-dropdown">
                               ${Object.entries(fantasyData.leagues).map(([leagueId, league]) => `
                                   <option value="${leagueId}" ${leagueId === activeLeagueId ? 'selected' : ''}>
                                       ${league.leagueName}
                                   </option>
                               `).join('')}
                           </select>
                       </div>
                       
                       <div class="filter-group">
                           <label for="team-select">Team:</label>
                           <select id="team-select" class="filter-dropdown">
                               <option value="ALL">All Teams</option>
                               ${activeLeague && activeLeague.teams ? activeLeague.teams.map(team => `
                                   <option value="${team.teamId}" ${team.teamId === currentFilters.team ? 'selected' : ''}>
                                       ${team.teamName}
                                   </option>
                               `).join('') : ''}
                           </select>
                       </div>
                   ` : ''}
               </div>
               
               <div class="api-status">
                   <div class="api-info">
                       ${apiState.loading ? 
                           '<span class="loading">Loading...</span>' : 
                           `<span class="record-count">${apiState.totalRecords} total records</span>`
                       }
                       ${apiState.error ? `<span class="error">${apiState.error}</span>` : ''}
                   </div>
                   
                   ${apiState.totalPages > 1 ? `
                       <div class="pagination-info">
                           Page ${apiState.currentPage} of ${apiState.totalPages}
                           ${apiState.hasMore ? '<button id="load-more-btn" class="load-more-btn">Load More</button>' : ''}
                       </div>
                   ` : ''}
               </div>
           `;
       }

       // Load stats function
       async function loadStats(resetPage = true) {
           if (resetPage) {
               apiState.currentPage = 1;
               currentPlayers = [];
           }

           apiState.loading = true;
           apiState.error = null;
           
           updateFilterControlsUI();
           
           try {
               const data = await statsAPI.fetchStats(
                   currentFilters.year,
                   currentFilters.week,
                   currentFilters.position,
                   apiState.currentPage
               );
               
               if (resetPage) {
                   currentPlayers = data.data;
               } else {
                   currentPlayers = [...currentPlayers, ...data.data];
               }
               
               apiState.totalPages = data.pagination.totalPages;
               apiState.totalRecords = data.pagination.totalRecords;
               apiState.hasMore = data.pagination.hasNext;
               apiState.loading = false;
               
               console.log(`✅ Loaded ${data.count} players, total: ${currentPlayers.length}`);
               
           } catch (error) {
               console.error('Failed to load stats:', error);
               apiState.error = error.message;
               apiState.loading = false;
           }
           
           updateFilterControlsUI();
           render();
       }

       // Event listeners
       function setupEventListeners() {
           // Year filter
           document.getElementById('year-select')?.addEventListener('change', async (e) => {
               currentFilters.year = e.target.value;
               currentFilters.week = 'total'; // Reset week when year changes
               await loadStats(true);
           });
           
           // Week filter  
           document.getElementById('week-select')?.addEventListener('change', async (e) => {
               currentFilters.week = e.target.value;
               saveWeekPreference(e.target.value);
               await loadStats(true);
           });
           
           // League filter
           document.getElementById('league-select')?.addEventListener('change', async (e) => {
               currentFilters.league = e.target.value;
               localStorage.setItem('activeLeagueId', e.target.value);
               updateFilterControlsUI(); // Update team dropdown
               render(); // Just re-render, don't reload stats
           });
           
           // Team filter
           document.getElementById('team-select')?.addEventListener('change', (e) => {
               currentFilters.team = e.target.value;
               render();
           });
           
           // Load more button
           document.getElementById('load-more-btn')?.addEventListener('click', async () => {
               if (apiState.hasMore && !apiState.loading) {
                   apiState.currentPage++;
                   await loadStats(false);
               }
           });
           
           // View toggle buttons
           document.querySelectorAll('.view-btn').forEach(btn => {
               btn.addEventListener('click', (e) => {
                   document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                   e.target.classList.add('active');
                   currentView = e.target.dataset.view;
                   render();
               });
           });

           // Search
           document.getElementById('searchInput').addEventListener('input', (e) => {
               searchQuery = e.target.value.toLowerCase();
               render();
           });
           
           // Position filter buttons
           document.getElementById('positionFilter').addEventListener('click', async (e) => {
               if (e.target.classList.contains('position-btn')) {
                   document.querySelectorAll('.position-btn').forEach(btn => btn.classList.remove('active'));
                   e.target.classList.add('active');
                   currentFilters.position = e.target.dataset.position;
                   await loadStats(true);
               }
           });
       }

       // Update filter controls UI
       function updateFilterControlsUI() {
           const filterContainer = document.querySelector('.filter-controls-container');
           if (filterContainer) {
               filterContainer.innerHTML = createFilterControls();
               setupEventListeners();
           }
       }

       // Get filtered players
       function getFilteredPlayers() {
           let filteredPlayers = currentPlayers;
           
           // Apply search filter
           if (searchQuery) {
               filteredPlayers = filteredPlayers.filter(player => {
                   return player.name.toLowerCase().includes(searchQuery) ||
                          player.team.toLowerCase().includes(searchQuery);
               });
           }
           
           return filteredPlayers;
       }

       // Fantasy points calculation
       function calculateFantasyPoints(statName, statValue) {
           // Use the active league's scoring rules if available
           const scoringRules = window.activeLeagueScoringRules || {};
           
           // Find the stat ID for the given stat name
           const statId = Object.keys(statsAPI.statIdMapping).find(id => 
               statsAPI.statIdMapping[id] === statName
           );
           
           if (!statId || !scoringRules[statId] || statValue === 0) {
               return 0;
           }
           
           const rule = scoringRules[statId];
           let points = statValue * rule.points;
           
           // Add bonus points if applicable
           if (rule.bonuses && Array.isArray(rule.bonuses)) {
               rule.bonuses.forEach(bonusRule => {
                   if (statValue >= bonusRule.bonus.target) {
                       points += parseFloat(bonusRule.bonus.points);
                   }
               });
           }
           
           return Math.round(points * 100) / 100;
       }

       // Render functions
       function render() {
           const content = document.getElementById('content');
           const filteredPlayers = getFilteredPlayers();

           if (filteredPlayers.length === 0) {
               content.innerHTML = `
                   <div class="empty-state">
                       <div class="empty-state-icon">🏈</div>
                       <h3>No players found</h3>
                       <p>Try adjusting your filters or search terms</p>
                   </div>
               `;
               return;
           }

           switch (currentView) {
               case 'cards':
                   renderCardsView(filteredPlayers);
                   break;
               case 'comparison':
                   renderComparisonView(filteredPlayers);
                   break;
               case 'stats':
                   renderStatsView(filteredPlayers);
                   break;
           }
       }

       function renderCardsView(players) {
           const content = document.getElementById('content');
           content.innerHTML = `
               <div class="player-grid">
                   ${players.map(player => renderPlayerCard(player)).join('')}
               </div>
           `;
       }

       function renderPlayerCard(player) {
           const stats = keyStats[player.position] || [];
           
           return `
               <div class="player-card fade-in">
                   <div class="player-header">
                       <div class="player-info">
                           <h3>${player.name}</h3>
                           <div class="player-meta">
                               <span class="position-badge">${player.position}</span>
                               <span>${player.team}</span>
                           </div>
                       </div>
                   </div>
                   <div class="stat-grid">
                       ${stats.map(stat => {
                           const value = player.stats[stat] || 0;
                           const fantasyPoints = calculateFantasyPoints(stat, value);
                           const isBest = checkIfBestStat(player, stat);
                           return `
                               <div class="stat-item ${isBest ? 'stat-best' : ''}">
                                   <span class="stat-value">${formatStatValue(value, stat)}</span>
                                   <span class="stat-label">${stat}</span>
                                   ${fantasyPoints > 0 ? `<div class="fantasy-points">${fantasyPoints} pts</div>` : ''}
                               </div>
                           `;
                       }).join('')}
                   </div>
               </div>
           `;
       }

       function renderComparisonView(players) {
           const content = document.getElementById('content');
           const stats = getStatsForPosition(currentFilters.position);
           
           content.innerHTML = `
               <div class="comparison-container fade-in">
                   <div class="comparison-header">
                       <h2>Player Comparison</h2>
                   </div>
                   <div class="comparison-table-wrapper">
                       <table class="comparison-table">
                           <thead>
                               <tr>
                                   <th>Player</th>
                                   ${stats.map(stat => `<th>${stat}</th>`).join('')}
                               </tr>
                           </thead>
                           <tbody>
                               ${players.map(player => `
                                   <tr>
                                       <td class="player-name-cell">${player.name}</td>
                                       ${stats.map(stat => {
                                           const value = player.stats[stat] || 0;
                                           const fantasyPoints = calculateFantasyPoints(stat, value);
                                           const isBest = checkIfBestStat(player, stat);
                                           return `
                                               <td ${isBest ? 'style="color: #2e7d32; font-weight: 600;"' : ''}>
                                                   ${formatStatValue(value, stat)}
                                                   ${fantasyPoints > 0 ? `<br><span style="font-size: 12px; color: #2a5298;">${fantasyPoints} pts</span>` : ''}
                                               </td>
                                           `;
                                       }).join('')}
                                   </tr>
                               `).join('')}
                           </tbody>
                       </table>
                   </div>
               </div>
           `;
       }

       function renderStatsView(players) {
           const content = document.getElementById('content');
           const stats = getStatsForPosition(currentFilters.position);
           const statCategories = categorizeStats(stats);
           
           content.innerHTML = `
               <div class="stats-overview fade-in">
                   <h2>Leaders</h2>
                   ${Object.entries(statCategories).map(([category, categoryStats]) => `
                       <div class="stat-category">
                           <div class="stat-category-title">${category}</div>
                           ${categoryStats.map(stat => {
                               const leaders = getStatLeaders(players, stat, 3);
                               return `
                                   <div class="stat-row">
                                       <span>${stat}</span>
                                       <span>${leaders.map(l => {
                                           const fantasyPoints = calculateFantasyPoints(stat, l.value);
                                           return `${l.name} (${formatStatValue(l.value, stat)}${fantasyPoints > 0 ? `, ${fantasyPoints} pts` : ''})`;
                                       }).join(', ')}</span>
                                   </div>
                               `;
                           }).join('')}
                       </div>
                   `).join('')}
               </div>
           `;
       }

       // Helper functions
       function getStatsForPosition(position) {
           if (position === 'ALL') {
               const allStats = new Set();
               Object.values(positionStats).forEach(stats => {
                   stats.forEach(stat => allStats.add(stat));
               });
               return Array.from(allStats);
           }
           return positionStats[position] || [];
       }

       function categorizeStats(stats) {
           const categories = {
               "Passing": ["Pass Att", "Comp", "Inc", "Pass Yds", "Pass TD", "Int", "Sack"],
               "Rushing": ["Rush Att", "Rush Yds", "Rush TD"],
               "Receiving": ["Rec", "Rec Yds", "Rec TD"],
               "Defense": ["Tack Solo", "Tack Ast", "Pass Def", "Sack", "Int", "Fum Rec", "Fum Force", "TD", "Safe", "Blk Kick"],
               "Special Teams": ["Ret Yds", "Ret TD", "FG", "FGM", "Pts Allow"],
               "Turnovers": ["Fum", "Fum Lost", "Off Fum Ret TD"],
               "Scoring": ["2-PT"]
           };

           const result = {};
           stats.forEach(stat => {
               for (const [category, categoryStats] of Object.entries(categories)) {
                   if (categoryStats.includes(stat)) {
                       if (!result[category]) result[category] = [];
                       result[category].push(stat);
                       break;
                   }
               }
           });
           return result;
       }

       function getStatLeaders(players, stat, limit = 3) {
           return players
               .filter(p => p.stats[stat] !== undefined)
               .map(p => ({ name: p.name, value: p.stats[stat] || 0 }))
               .sort((a, b) => {
                   if (stat === 'Int' || stat === 'Fum Lost' || stat === 'FGM' || stat === 'Pts Allow') {
                       return a.value - b.value;
                   }
                   return b.value - a.value;
               })
               .slice(0, limit);
       }

       function checkIfBestStat(player, stat) {
           const players = getFilteredPlayers().filter(p => p.position === player.position);
           const values = players.map(p => p.stats[stat] || 0);
           const playerValue = player.stats[stat] || 0;
           
           if (stat === 'Int' || stat === 'Fum Lost' || stat === 'FGM' || stat === 'Pts Allow') {
               return playerValue === Math.min(...values) && playerValue > 0;
           }
           return playerValue === Math.max(...values) && playerValue > 0;
       }

       function formatStatValue(value, stat) {
           if (stat === 'Sack' || stat === 'Pass Def') {
               return value.toFixed(1);
           }
           if (stat === 'FG') {
               return `${value} Att`;
           }
           if (stat === 'FGM') {
               return `${value} Miss`;
           }
           return value.toString();
       }

       // Initialize
       document.addEventListener('DOMContentLoaded', async () => {
           // Initialize active league
           currentFilters.league = initializeActiveLeague();
           
           // Load saved week preference
           currentFilters.week = getSavedWeek();
           
           // Add filter controls to header
           const header = document.querySelector('.header');
           const filterControlsHtml = createFilterControls();
           if (filterControlsHtml && header) {
               const filterContainer = document.createElement('div');
               filterContainer.className = 'filter-controls-container';
               filterContainer.innerHTML = filterControlsHtml;
               header.appendChild(filterContainer);
           }
           
           // Setup event listeners
           setupEventListeners();
           
           // Load initial stats data
           await loadStats(true);
       });
   </script>
</body>
</html>
