<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - Player Import</title>
    <style>
        /* ... your existing styles ... */
        
        .resume-section {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            display: none;
        }
        
        .resume-section h3 {
            color: #856404;
            margin-bottom: 15px;
        }
        
        .resume-button {
            background-color: #ffc107;
            color: #212529;
        }
        
        .resume-button:hover {
            background-color: #e0a800;
        }
        
        .progress-details {
            background-color: #f8f9fa;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 14px;
        }
        
        .error-recovery {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            display: none;
        }
        
        .checkpoint-info {
            background-color: #d1ecf1;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Admin - Player & Stats Import</h1>
        
        <!-- Resume Section -->
        <div class="resume-section" id="resumeSection">
            <h3>üîÑ Resume Previous Import</h3>
            <div class="checkpoint-info" id="resumeInfo"></div>
            <button class="resume-button" onclick="resumeImport()">Resume Import</button>
            <button class="cancel-button" onclick="clearProgress()">Clear Progress</button>
        </div>
        
        <!-- Error Recovery Section -->
        <div class="error-recovery" id="errorRecovery">
            <h3>‚ö†Ô∏è Import Error Detected</h3>
            <div id="errorDetails"></div>
            <div class="modal-buttons">
                <button class="resume-button" onclick="retryCurrentBatch()">Retry Current Batch</button>
                <button onclick="skipCurrentBatch()">Skip Current Batch</button>
                <button class="cancel-button" onclick="clearProgress()">Abort Import</button>
            </div>
        </div>
        
        <!-- ... your existing sections ... -->
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar">0%</div>
        </div>
        
        <div class="progress-details" id="progressDetails" style="display: none;">
            <div><strong>Current Operation:</strong> <span id="currentOperation">Initializing...</span></div>
            <div><strong>Batch Progress:</strong> <span id="batchProgress">0/0</span></div>
            <div><strong>Week Progress:</strong> <span id="weekProgress">0/18</span></div>
            <div><strong>Total Players:</strong> <span id="totalPlayersCount">0</span></div>
            <div><strong>Last Checkpoint:</strong> <span id="lastCheckpoint">None</span></div>
            <div><strong>Estimated Time Remaining:</strong> <span id="timeRemaining">Calculating...</span></div>
        </div>
        
        <div id="status"></div>
        <div id="results"></div>
    </div>
    
    <!-- ... your existing modal ... -->

<script>
// Enhanced global variables with persistence
let importState = {
    isImporting: false,
    year: null,
    maxPlayers: null,
    playerBatches: [],
    currentWeek: 1,
    currentBatchIndex: 0,
    totalPlayersProcessed: 0,
    totalWeeksCompleted: 0,
    totalSeasonTotalsProcessed: 0,
    completedOperations: new Set(), // Track completed week-batch combinations
    failedOperations: new Map(), // Track failed operations with retry count
    startTime: null,
    lastCheckpointTime: null,
    performanceMetrics: {
        totalTimeMs: 0,
        totalApiCalls: 0,
        totalFetchTimeMs: 0,
        avgPlayersPerSecond: 0,
        fastestWeekMs: Infinity,
        slowestWeekMs: 0,
        weeklyPerformance: []
    }
};

const STORAGE_KEY = 'nfl_import_progress';
const MAX_RETRIES = 3;
const CHECKPOINT_INTERVAL = 5000; // Save progress every 5 seconds

// Load progress from localStorage on page load
document.addEventListener('DOMContentLoaded', function() {
    loadProgressFromStorage();
    checkForResumableImport();
});

// Save progress to localStorage
function saveProgressToStorage() {
    try {
        const progressData = {
            ...importState,
            timestamp: Date.now()
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(progressData));
    } catch (error) {
        console.error('Failed to save progress:', error);
    }
}

// Load progress from localStorage
function loadProgressFromStorage() {
    try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            const progressData = JSON.parse(saved);
            // Only restore if it's recent (within 24 hours)
            if (Date.now() - progressData.timestamp < 24 * 60 * 60 * 1000) {
                importState = { ...importState, ...progressData };
            }
        }
    } catch (error) {
        console.error('Failed to load progress:', error);
    }
}

// Check for resumable import
function checkForResumableImport() {
    if (importState.year && importState.playerBatches.length > 0 && !importState.isImporting) {
        const resumeSection = document.getElementById('resumeSection');
        const resumeInfo = document.getElementById('resumeInfo');
        
        const completed = importState.completedOperations.size;
        const total = importState.playerBatches.length * 18;
        const percent = Math.round((completed / total) * 100);
        
        resumeInfo.innerHTML = `
            <strong>Year:</strong> ${importState.year}<br>
            <strong>Progress:</strong> ${completed}/${total} operations (${percent}%)<br>
            <strong>Current Week:</strong> ${importState.currentWeek}/18<br>
            <strong>Failed Operations:</strong> ${importState.failedOperations.size}<br>
            <strong>Last Saved:</strong> ${new Date(importState.timestamp).toLocaleTimeString()}
        `;
        
        resumeSection.style.display = 'block';
    }
}

// Clear progress data
function clearProgress() {
    localStorage.removeItem(STORAGE_KEY);
    importState = {
        isImporting: false,
        year: null,
        maxPlayers: null,
        playerBatches: [],
        currentWeek: 1,
        currentBatchIndex: 0,
        totalPlayersProcessed: 0,
        totalWeeksCompleted: 0,
        totalSeasonTotalsProcessed: 0,
        completedOperations: new Set(),
        failedOperations: new Map(),
        startTime: null,
        lastCheckpointTime: null,
        performanceMetrics: {
            totalTimeMs: 0,
            totalApiCalls: 0,
            totalFetchTimeMs: 0,
            avgPlayersPerSecond: 0,
            fastestWeekMs: Infinity,
            slowestWeekMs: 0,
            weeklyPerformance: []
        }
    };
    
    document.getElementById('resumeSection').style.display = 'none';
    document.getElementById('errorRecovery').style.display = 'none';
    showStatus('Progress cleared.', 'info');
}

// Resume import from saved progress
async function resumeImport() {
    if (!importState.year || importState.playerBatches.length === 0) {
        showStatus('No valid import state to resume.', 'error');
        return;
    }
    
    document.getElementById('resumeSection').style.display = 'none';
    showStatus('Resuming import from last checkpoint...', 'info');
    
    // Continue the import process from where we left off
    await continueStatsImport();
}

// Enhanced stats import with checkpointing
async function confirmStatsImport() {
    closeModal();
    
    // Clear any existing progress
    clearProgress();
    
    const year = parseInt(document.getElementById('seasonYear').value);
    const maxPlayers = parseInt(document.getElementById('maxPlayers').value);
    
    // Initialize import state
    importState = {
        isImporting: true,
        year: year,
        maxPlayers: maxPlayers,
        playerBatches: [],
        currentWeek: 1,
        currentBatchIndex: 0,
        totalPlayersProcessed: 0,
        totalWeeksCompleted: 0,
        totalSeasonTotalsProcessed: 0,
        completedOperations: new Set(),
        failedOperations: new Map(),
        startTime: Date.now(),
        lastCheckpointTime: Date.now(),
        performanceMetrics: {
            totalTimeMs: 0,
            totalApiCalls: 0,
            totalFetchTimeMs: 0,
            avgPlayersPerSecond: 0,
            fastestWeekMs: Infinity,
            slowestWeekMs: 0,
            weeklyPerformance: []
        }
    };
    
    await continueStatsImport();
}

// Continue stats import (used for both new and resumed imports)
async function continueStatsImport() {
    const importBtn = document.getElementById('importStatsBtn');
    const progressContainer = document.getElementById('progressContainer');
    const progressDetails = document.getElementById('progressDetails');
    
    importBtn.disabled = true;
    progressContainer.style.display = 'block';
    progressDetails.style.display = 'block';
    
    // Start checkpoint saving
    const checkpointInterval = setInterval(() => {
        if (importState.isImporting) {
            saveProgressToStorage();
            updateProgressDisplay();
        } else {
            clearInterval(checkpointInterval);
        }
    }, CHECKPOINT_INTERVAL);
    
    try {
        // Step 1: Collect player batches (skip if already collected)
        if (importState.playerBatches.length === 0) {
            await collectPlayerBatches();
        }
        
        // Step 2: Process weekly stats
        await processWeeklyStats();
        
        // Step 3: Process season totals
        await processSeasonTotals();
        
        // Import completed successfully
        importState.isImporting = false;
        showStatus('üéâ Import completed successfully!', 'success');
        displayEnhancedStatsSummary();
        clearProgress(); // Clear progress after successful completion
        
    } catch (error) {
        console.error('Stats import error:', error);
        handleImportError(error);
    } finally {
        importBtn.disabled = false;
        clearInterval(checkpointInterval);
        saveProgressToStorage();
    }
}

// Collect player batches with error handling
async function collectPlayerBatches() {
    updateCurrentOperation('Collecting player batches...');
    
    let start = 0;
    while (start < importState.maxPlayers) {
        const batchSize = Math.min(25, importState.maxPlayers - start);
        
        try {
            const response = await fetch('/data/admin/stats', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'include',
                body: JSON.stringify({
                    year: importState.year,
                    week: 1,
                    start: start,
                    count: batchSize,
                    max: importState.maxPlayers,
                    useStoredKeys: false
                })
            });
            
            if (!response.ok) {
                throw new Error(`Failed to get player batch: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (!data.playerKeys || !data.playerInfoData || data.playerKeys.length === 0) {
                throw new Error('Invalid player data received');
            }
            
            importState.playerBatches.push({
                start: start,
                count: batchSize,
                playerKeys: data.playerKeys,
                playerInfoData: data.playerInfoData
            });
            
            updateProgressDisplay();
            
            if (!data.hasMore || data.importedCount === 0) {
                break;
            }
            
            start += batchSize;
            await new Promise(resolve => setTimeout(resolve, 300));
            
        } catch (error) {
            console.error(`Error collecting batch at start=${start}:`, error);
            throw new Error(`Failed to collect player batch: ${error.message}`);
        }
    }
    
    if (importState.playerBatches.length === 0) {
        throw new Error('No player batches collected!');
    }
    
    showStatus(`Collected ${importState.playerBatches.length} player batches`, 'success');
}

// Process weekly stats with resumption
async function processWeeklyStats() {
    const totalBatches = importState.playerBatches.length;
    
    for (let week = importState.currentWeek; week <= 18; week++) {
        importState.currentWeek = week;
        const weekStartTime = Date.now();
        
        updateCurrentOperation(`Processing Week ${week} of 18...`);
        
        let weekPlayersProcessed = 0;
        
        for (let batchIndex = importState.currentBatchIndex; batchIndex < totalBatches; batchIndex++) {
            importState.currentBatchIndex = batchIndex;
            const operationKey = `week-${week}-batch-${batchIndex}`;
            
            // Skip if already completed
            if (importState.completedOperations.has(operationKey)) {
                continue;
            }
            
            // Check retry limit
            const retryCount = importState.failedOperations.get(operationKey) || 0;
            if (retryCount >= MAX_RETRIES) {
                console.warn(`Skipping ${operationKey} - max retries exceeded`);
                continue;
            }
            
            try {
                const batch = importState.playerBatches[batchIndex];
                
                const response = await fetch('/data/admin/stats', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        year: importState.year,
                        week: week,
                        playerKeys: batch.playerKeys,
                        playerInfoData: batch.playerInfoData,
                        useStoredKeys: true
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                weekPlayersProcessed += data.importedCount;
                importState.totalPlayersProcessed += data.importedCount;
                
                // Mark as completed
                importState.completedOperations.add(operationKey);
                importState.failedOperations.delete(operationKey);
                
                updateProgressDisplay();
                
            } catch (error) {
                console.error(`Error processing ${operationKey}:`, error);
                
                // Track failure
                importState.failedOperations.set(operationKey, retryCount + 1);
                
                // Show error but continue
                showStatus(`‚ö†Ô∏è Failed ${operationKey} (retry ${retryCount + 1}/${MAX_RETRIES}): ${error.message}`, 'error');
                
                // Don't throw - just continue to next batch
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            await new Promise(resolve => setTimeout(resolve, 300));
        }
        
        // Reset batch index for next week
        importState.currentBatchIndex = 0;
        
        const weekDuration = Date.now() - weekStartTime;
        importState.performanceMetrics.weeklyPerformance.push({
            week: week,
            duration: weekDuration,
            playersProcessed: weekPlayersProcessed,
            playersPerSecond: Math.round(weekPlayersProcessed / (weekDuration / 1000))
        });
        
        if (weekPlayersProcessed > 0) {
            showStatus(`‚úÖ Week ${week} complete: ${weekPlayersProcessed} players`, 'success');
        }
        
        importState.totalWeeksCompleted = week;
        saveProgressToStorage();
    }
}

// Process season totals
async function processSeasonTotals() {
    updateCurrentOperation('Processing season totals...');
    
    for (let batchIndex = 0; batchIndex < importState.playerBatches.length; batchIndex++) {
        const operationKey = `totals-batch-${batchIndex}`;
        
        if (importState.completedOperations.has(operationKey)) {
            continue;
        }
        
        try {
            const batch = importState.playerBatches[batchIndex];
            
            const response = await fetch('/data/admin/stats', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'include',
                body: JSON.stringify({
                    year: importState.year,
                    playerKeys: batch.playerKeys,
                    playerInfoData: batch.playerInfoData,
                    fetchTotals: true
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                importState.totalSeasonTotalsProcessed += data.totalsImported || 0;
                importState.completedOperations.add(operationKey);
                updateProgressDisplay();
            }
            
        } catch (error) {
            console.error(`Error processing season totals batch ${batchIndex}:`, error);
        }
        
        await new Promise(resolve => setTimeout(resolve, 500));
    }
}

// Update current operation display
function updateCurrentOperation(operation) {
    document.getElementById('currentOperation').textContent = operation;
}

// Update progress display
function updateProgressDisplay() {
    const totalOperations = importState.playerBatches.length * 18;
    const completed = importState.completedOperations.size;
    const progressPercent = Math.round((completed / totalOperations) * 100);
    
    document.getElementById('progressBar').style.width = progressPercent + '%';
    document.getElementById('progressBar').textContent = progressPercent + '%';
    
    document.getElementById('batchProgress').textContent = 
        `${importState.currentBatchIndex + 1}/${importState.playerBatches.length}`;
    document.getElementById('weekProgress').textContent = 
        `${importState.currentWeek}/18`;
    document.getElementById('totalPlayersCount').textContent = 
        importState.totalPlayersProcessed.toLocaleString();
    document.getElementById('lastCheckpoint').textContent = 
        new Date().toLocaleTimeString();
    
    // Calculate estimated time remaining
    if (importState.startTime && completed > 0) {
        const elapsed = Date.now() - importState.startTime;
        const rate = completed / elapsed;
        const remaining = (totalOperations - completed) / rate;
        const remainingMinutes = Math.round(remaining / 60000);
        
        document.getElementById('timeRemaining').textContent = 
            remainingMinutes > 0 ? `~${remainingMinutes} minutes` : 'Almost done!';
    }
}

// Handle import errors
function handleImportError(error) {
    importState.isImporting = false;
    
    const errorRecovery = document.getElementById('errorRecovery');
    const errorDetails = document.getElementById('errorDetails');
    
    errorDetails.innerHTML = `
        <strong>Error:</strong> ${error.message}<br>
        <strong>Current Week:</strong> ${importState.currentWeek}<br>
        <strong>Current Batch:</strong> ${importState.currentBatchIndex + 1}/${importState.playerBatches.length}<br>
        <strong>Operations Completed:</strong> ${importState.completedOperations.size}<br>
        <strong>Failed Operations:</strong> ${importState.failedOperations.size}
    `;
    
    errorRecovery.style.display = 'block';
    showStatus(`‚ùå Import failed: ${error.message}`, 'error');
    saveProgressToStorage();
}

// Retry current batch
async function retryCurrentBatch() {
    document.getElementById('errorRecovery').style.display = 'none';
    showStatus('Retrying current batch...', 'info');
    
    // Clear the failed operation to allow retry
    const operationKey = `week-${importState.currentWeek}-batch-${importState.currentBatchIndex}`;
    importState.failedOperations.delete(operationKey);
    
    await resumeImport();
}

// Skip current batch
async function skipCurrentBatch() {
    document.getElementById('errorRecovery').style.display = 'none';
    
    const operationKey = `week-${importState.currentWeek}-batch-${importState.currentBatchIndex}`;
    importState.completedOperations.add(operationKey); // Mark as completed to skip
    importState.currentBatchIndex++;
    
    showStatus('Skipping current batch...', 'info');
    await resumeImport();
}

// Show stats confirmation modal
function showStatsConfirmation() {
    const year = document.getElementById('seasonYear').value;
    const maxPlayers = document.getElementById('maxPlayers').value;
    const batchSize = document.getElementById('batchSize').value;
    
    document.getElementById('modalYear').textContent = year;
    document.getElementById('modalMaxPlayers').textContent = maxPlayers;
    document.getElementById('modalBatchSize').textContent = batchSize;
    document.getElementById('confirmModal').style.display = 'block';
}

// Close modal
function closeModal() {
    document.getElementById('confirmModal').style.display = 'none';
}

// COMPLETE: Confirm and import stats with frontend-controlled batching
async function confirmStatsImport() {
    closeModal();
    
    const year = parseInt(document.getElementById('seasonYear').value);
    const maxPlayers = parseInt(document.getElementById('maxPlayers').value);
    const batchSize = parseInt(document.getElementById('batchSize').value);
    const importBtn = document.getElementById('importStatsBtn');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    
    // Reset global variables
    playerBatches = [];
    totalPlayersProcessed = 0;
    totalWeeksCompleted = 0;
    totalSeasonTotalsProcessed = 0;
    performanceMetrics = {
        totalTimeMs: 0,
        totalApiCalls: 0,
        totalFetchTimeMs: 0,
        avgPlayersPerSecond: 0,
        fastestWeekMs: Infinity,
        slowestWeekMs: 0,
        weeklyPerformance: []
    };
    
    importBtn.disabled = true;
    progressContainer.style.display = 'block';
    showStatus(`Starting import of ${year} season stats with batch size ${batchSize}...`, 'info');
    
    const overallStartTime = Date.now();
    
    try {
        // STEP 1: Collect all player batches using frontend-controlled batching
        showStatus(`Step 1: Collecting player keys and info (batch size: ${batchSize})...`, 'info');
        
        let start = 0;
        let batchNumber = 1;
        
        while (start < maxPlayers) {
            const currentBatchSize = Math.min(batchSize, maxPlayers - start);
            
            showStatus(`Collecting batch ${batchNumber}: players ${start + 1}-${start + currentBatchSize}...`, 'info');
            console.log(`Fetching player batch ${batchNumber}: start=${start}, count=${currentBatchSize}`);
            
            // Get player keys AND player info for this batch
            const response = await fetch('/data/admin/stats', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'include',
                body: JSON.stringify({
                    year: year,
                    week: 1,
                    start: start,
                    count: currentBatchSize,
                    max: maxPlayers,
                    useStoredKeys: false
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `Failed to get player keys: ${response.status}`);
            }
            
            const data = await response.json();
            
            console.log(`Received batch ${batchNumber} data:`, data);
            
            // Validate we got player keys and info
            if (!data.playerKeys || !data.playerInfoData || data.playerKeys.length === 0) {
                console.error('Missing player keys or info data:', data);
                throw new Error(`Failed to get valid player keys and info from API for batch ${batchNumber}`);
            }
            
            // Store the player keys AND real player info for this batch
            playerBatches.push({
                batchNumber: batchNumber,
                start: start,
                count: currentBatchSize,
                playerKeys: data.playerKeys,
                playerInfoData: data.playerInfoData
            });
            
            performanceMetrics.totalApiCalls++;
            performanceMetrics.totalFetchTimeMs += data.performance?.totalTimeMs || 0;
            
            console.log(`Stored batch ${batchNumber}: ${data.playerKeys.length} players`);
            
            // Update progress for player collection phase
            const collectionProgress = Math.round((start + currentBatchSize) / maxPlayers * 20); // 20% for collection
            progressBar.style.width = collectionProgress + '%';
            progressBar.textContent = `Collecting: ${collectionProgress}%`;
            
            if (!data.hasMore || data.importedCount === 0) {
                break;
            }
            
            start += currentBatchSize;
            batchNumber++;
            
            // Short delay between batch collections
            await new Promise(resolve => setTimeout(resolve, 200));
        }
        
        if (playerBatches.length === 0) {
            throw new Error('No player batches collected!');
        }
        
        const totalPlayersCollected = playerBatches.reduce((sum, batch) => sum + batch.playerKeys.length, 0);
        showStatus(`Collected ${playerBatches.length} batches with ${totalPlayersCollected} total players. Starting weekly import...`, 'info');
        
        // STEP 2: Process all weeks for all player batches
        const totalBatches = playerBatches.length;
        const totalOperations = totalBatches * 18; // 18 weeks
        let completedOperations = Math.round(totalPlayersCollected / maxPlayers * 20); // Start from collection progress
        
        for (let week = 1; week <= 18; week++) {
            const weekStartTime = Date.now();
            showStatus(`Processing Week ${week} of 18 (${totalBatches} batches)...`, 'info');
            
            let weekPlayersProcessed = 0;
            
            for (let batchIndex = 0; batchIndex < playerBatches.length; batchIndex++) {
                const batch = playerBatches[batchIndex];
                
                console.log(`Processing week ${week}, batch ${batch.batchNumber}/${totalBatches} (${batch.playerKeys.length} players)`);
                
                // Use the stored player keys and info for this week
                const requestBody = {
                    year: year,
                    week: week,
                    batchSize: batch.playerKeys.length, // Pass actual batch size
                    playerKeys: batch.playerKeys,
                    playerInfoData: batch.playerInfoData,
                    useStoredKeys: true
                };
                
                const response = await fetch('/data/admin/stats', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify(requestBody)
                });
                
                if (response.ok) {
                    const data = await response.json();
                    weekPlayersProcessed += data.importedCount;
                    
                    // Track performance metrics
                    performanceMetrics.totalApiCalls++;
                    performanceMetrics.totalFetchTimeMs += data.performance?.totalTimeMs || 0;
                    
                    console.log(`Week ${week} batch ${batch.batchNumber} complete: ${data.importedCount} players`);
                } else {
                    const errorData = await response.json();
                    console.error(`Failed to process week ${week} batch ${batch.batchNumber}:`, response.status, errorData);
                }
                
                // Update progress (20% for collection + 75% for weeks + 5% for totals)
                completedOperations++;
                const progressPercent = Math.min(95, 20 + Math.round((completedOperations - 20) / totalOperations * 75));
                progressBar.style.width = progressPercent + '%';
                progressBar.textContent = `Week ${week}: ${progressPercent}%`;
                
                // Short delay between batches
                await new Promise(resolve => setTimeout(resolve, 150));
            }
            
            const weekDuration = Date.now() - weekStartTime;
            performanceMetrics.weeklyPerformance.push({
                week: week,
                duration: weekDuration,
                playersProcessed: weekPlayersProcessed,
                playersPerSecond: Math.round(weekPlayersProcessed / (weekDuration / 1000))
            });
            
            // Track fastest/slowest weeks
            if (weekDuration < performanceMetrics.fastestWeekMs) {
                performanceMetrics.fastestWeekMs = weekDuration;
            }
            if (weekDuration > performanceMetrics.slowestWeekMs) {
                performanceMetrics.slowestWeekMs = weekDuration;
            }
            
            totalPlayersProcessed += weekPlayersProcessed;
            totalWeeksCompleted++;
            
            showStatus(`‚úÖ Week ${week} complete: ${weekPlayersProcessed} players in ${(weekDuration/1000).toFixed(1)}s`, 'success');
            await new Promise(resolve => setTimeout(resolve, 300));
        }
        
        // STEP 3: Fetch season totals for all player batches
        showStatus(`Step 3: Fetching season totals...`, 'info');
        
        for (let batchIndex = 0; batchIndex < playerBatches.length; batchIndex++) {
            const batch = playerBatches[batchIndex];
            
            console.log(`Fetching season totals for batch ${batch.batchNumber}/${playerBatches.length}`);
            
            const response = await fetch('/data/admin/stats', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'include',
                body: JSON.stringify({
                    year: year,
                    batchSize: batch.playerKeys.length, // Pass actual batch size
                    playerKeys: batch.playerKeys,
                    playerInfoData: batch.playerInfoData,
                    fetchTotals: true
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                totalSeasonTotalsProcessed += data.totalsImported || 0;
                
                console.log(`Season totals batch ${batch.batchNumber} complete: ${data.totalsImported} players`);
            } else {
                const errorData = await response.json();
                console.error(`Failed to fetch season totals for batch ${batch.batchNumber}:`, response.status, errorData);
            }
            
            // Final progress update
            const finalProgress = 95 + Math.round((batchIndex + 1) / playerBatches.length * 5);
            progressBar.style.width = finalProgress + '%';
            progressBar.textContent = `Totals: ${finalProgress}%`;
            
            await new Promise(resolve => setTimeout(resolve, 200));
        }
        
        // Final completion
        progressBar.style.width = '100%';
        progressBar.textContent = '100% Complete!';
        
        showStatus(`‚úÖ Season totals complete: ${totalSeasonTotalsProcessed} players`, 'success');
        
        const overallDuration = Date.now() - overallStartTime;
        performanceMetrics.totalTimeMs = overallDuration;
        performanceMetrics.avgPlayersPerSecond = Math.round(totalPlayersProcessed / (overallDuration / 1000));
        
        showStatus(`üéâ ALL DONE! Imported ${totalPlayersProcessed.toLocaleString()} weekly records + ${totalSeasonTotalsProcessed.toLocaleString()} season totals!`, 'success');
        
        // Display enhanced summary with performance metrics
        displayEnhancedStatsSummary(year, totalWeeksCompleted, totalPlayersProcessed, performanceMetrics, totalSeasonTotalsProcessed, batchSize);
        
    } catch (error) {
        console.error('Stats import error:', error);
        showStatus(`‚ùå Error: ${error.message}`, 'error');
    } finally {
        importBtn.disabled = false;
        progressContainer.style.display = 'none';
    }
}

// Enhanced stats summary with detailed performance metrics
function displayEnhancedStatsSummary(year, weeks, totalRecords, metrics, seasonTotals, batchSize) {
    const resultsDiv = document.getElementById('results');
    resultsDiv.style.display = 'block';
    
    // Find best and worst performing weeks
    let bestWeek = { week: 'N/A', playersPerSecond: 'N/A' };
    let worstWeek = { week: 'N/A', playersPerSecond: 'N/A' };
    
    if (metrics.weeklyPerformance.length > 0) {
        bestWeek = metrics.weeklyPerformance.reduce((best, current) => 
            current.playersPerSecond > best.playersPerSecond ? current : best
        );
        worstWeek = metrics.weeklyPerformance.reduce((worst, current) => 
            current.playersPerSecond < worst.playersPerSecond ? current : worst
        );
    }
    
    resultsDiv.innerHTML = `
        <h3>üìä Enhanced Stats Import Summary</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div>
                <h4>üìà Import Summary</h4>
                <div class="result-item"><strong>Year:</strong> ${year}</div>
                <div class="result-item"><strong>Weeks Processed:</strong> ${weeks}/18</div>
                <div class="result-item"><strong>Player Batches:</strong> ${playerBatches.length}</div>
                <div class="result-item"><strong>Batch Size:</strong> ${batchSize} players</div>
                <div class="result-item"><strong>Weekly Records:</strong> ${totalRecords.toLocaleString()}</div>
                <div class="result-item"><strong>Season Totals:</strong> ${seasonTotals.toLocaleString()}</div>
                <div class="result-item"><strong>Total API Calls:</strong> ${metrics.totalApiCalls}</div>
            </div>
            
            <div>
                <h4>‚ö° Performance Metrics</h4>
                <div class="result-item"><strong>Total Time:</strong> ${(metrics.totalTimeMs / 1000).toFixed(1)}s</div>
                <div class="result-item"><strong>Avg Players/Second:</strong> ${metrics.avgPlayersPerSecond}</div>
                <div class="result-item"><strong>Total Fetch Time:</strong> ${(metrics.totalFetchTimeMs / 1000).toFixed(1)}s</div>
                <div class="result-item"><strong>Fastest Week:</strong> Week ${bestWeek.week} (${bestWeek.playersPerSecond} p/s)</div>
                <div class="result-item"><strong>Slowest Week:</strong> Week ${worstWeek.week} (${worstWeek.playersPerSecond} p/s)</div>
                <div class="result-item"><strong>Avg Time/Batch:</strong> ${(metrics.totalFetchTimeMs / metrics.totalApiCalls).toFixed(1)}ms</div>
            </div>
        </div>
        
        <h4>üìä Weekly Performance Breakdown</h4>
        <div style="max-height: 200px; overflow-y: auto; background: #f8f9fa; padding: 10px; border-radius: 5px;">
            ${metrics.weeklyPerformance.map(week => `
                <div class="result-item">
                    <strong>Week ${week.week}:</strong> 
                    ${week.playersProcessed} players in ${(week.duration / 1000).toFixed(1)}s 
                    (${week.playersPerSecond} players/sec, ${playerBatches.length} batches)
                </div>
            `).join('')}
        </div>
        
        <h4>üîß Batch Configuration</h4>
        <div style="background: #f8f9fa; padding: 10px; border-radius: 5px;">
            <div class="result-item"><strong>Configured Batch Size:</strong> ${batchSize} players</div>
            <div class="result-item"><strong>Total Batches Created:</strong> ${playerBatches.length}</div>
            <div class="result-item"><strong>Players per Batch:</strong> ${playerBatches.map(b => b.playerKeys.length).join(', ')}</div>
        </div>
    `;
}

// Show status message
function showStatus(message, type) {
    const statusDiv = document.getElementById('status');
    statusDiv.textContent = message;
    statusDiv.className = type;
    statusDiv.style.display = 'block';
}

// Close modal when clicking outside
window.onclick = function(event) {
    const modal = document.getElementById('confirmModal');
    if (event.target === modal) {
        closeModal();
    }
}

</script>
</body>
</html>
